<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>enemyMaxHealth = 5;
enemyHealth = enemyMaxHealth;

type = 1;
targetX = (irandom(room_width) div gridSize)*gridSize;
targetY = (irandom(room_height) div gridSize)*gridSize;

canMove = true;
moveSpeed = 0.5;
fire = 0;
turretAngle = 0;
turretTurnRate = 1;
bodyAngle = 0;
bodyTurnRate = 1;
displayTurretAngle = 0;
displayBodyAngle = 0;
path = path_add();

e_reload = false;
e_reloadTime = 0;
e_reloadMaxTime = 120;
damage = 0;

/*********** TANK BODY *************/
switch(object_index) {
    case obj_enemy_1: case obj_enemy_2:
        tankBody = spr_tank_body;
        break;
    case obj_enemy_3:
        tankBody = spr_tank_body2;
        break;
    case obj_enemy_4:
        tankBody = spr_tank_body3;
        break;
    default:
        tankBody = -1;
        break;
}

xPrev = x;
yPrev = y;
xTo = x;
yTo = y;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (enemiesLeft == 0 &amp;&amp; checkAliveEnemies() == 0) {
    levelComplete = true;
}
else {
    if ((x &gt; view_xview[0] &amp;&amp; x &lt; view_xview[0]+view_wview[0]) &amp;&amp; (y &gt; view_yview[0] &amp;&amp; y &lt; view_yview[0]+view_hview[0])) {
        var ind = instance_create(x+(sprite_width/2),y+(sprite_height/2),obj_dmg_inc);
        ind.damage = 100*(type+1);
        ind.size = 1;
        ind.wait = -30;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*********** MOVING *************/
if (canMove) {
    if (xTo == x &amp;&amp; yTo == y) {
        if (xPrev != xTo || yPrev != yTo) {
            mp_grid_clear_cell(mpGrid, xPrev div gridSize, yPrev div gridSize);
            xPrev = x;
            yPrev = y;
        }
        var pathFound = false;
        mp_grid_clear_cell(mpGrid, x div gridSize, y div gridSize);
        switch(type) {
            case 0: case 2://Random
                var pathFound = mp_grid_path(mpGrid,path,x,y,targetX,targetY,false);
                if (!pathFound || (targetX == x &amp;&amp; targetY == y)) {
                    targetX = (irandom(room_width) div gridSize)*gridSize;
                    targetY = (irandom(room_height) div gridSize)*gridSize;
                }
                break;
            case 1: case 3://Chase
                if (instance_exists(obj_player)) {
                    targetX = obj_player.x;
                    targetY = obj_player.y;
                    mp_grid_clear_cell(mpGrid, targetX div gridSize, targetY div gridSize);
                    var pathFound = mp_grid_path(mpGrid,path,x,y,targetX,targetY,false);
                    mp_grid_add_cell(mpGrid, targetX div gridSize, targetY div gridSize);
                    if (!pathFound) {
                        targetX = (irandom(room_width) div gridSize)*gridSize;
                        targetY = (irandom(room_height) div gridSize)*gridSize;
                        pathFound = mp_grid_path(mpGrid,path,x,y,targetX,targetY,false);
                    }
                }
                break;
        }
        mp_grid_add_cell(mpGrid, x div gridSize, y div gridSize);
        if (pathFound) {
            xTo = (path_get_point_x(path,1) div gridSize)*gridSize;
            yTo = (path_get_point_y(path,1) div gridSize)*gridSize;
        }
        if (mp_grid_get_cell(mpGrid, xTo div gridSize, yTo div gridSize) == -1) {
            xTo = x;
            yTo = y;
        }
        else {
            mp_grid_add_cell(mpGrid, xTo div gridSize, yTo div gridSize);
        }
    }
    /*************** BODY **************/
    var a = sin(degtorad(displayBodyAngle));
    var d = sin(degtorad(direction));
    if (a == d) {
        if (x &gt; xTo) {
            if (place_free(x-min(moveSpeed,x-xTo),y)) {
                x -= min(moveSpeed,x-xTo);
                direction = 180;
            }
        }
        if (x &lt; xTo) {
            if (place_free(x+min(moveSpeed,xTo-x),y)) {
                x += min(moveSpeed,xTo-x);
                direction = 0;
            }
        }
        if (y &gt; yTo) {
            if (place_free(x,y-min(moveSpeed,y-yTo))) {
                y -= min(moveSpeed,y-yTo);
                direction = 90;
            }
        }
        if (y &lt; yTo) {
            if (place_free(x,y+min(moveSpeed,yTo-y))) {
                y += min(moveSpeed,yTo-y);
                direction = 270;
            }
        }
        image_index += 0.5;
    }
    else {
        var image_ad = angle_difference(direction,displayBodyAngle);
        displayBodyAngle += sign(image_ad)*bodyTurnRate;
        if (abs(image_ad) &gt; 0) {
            image_index += 0.5;
        }
    }
    if (instance_exists(obj_player)) {
        /************* turret *************/
        switch(type) {
            case 0: case 2://random
                displayTurretAngle = displayBodyAngle;
                break;
            case 1: case 3:
                turretAngle = (point_direction(x,y,obj_player.x,obj_player.y) div 90)*90;
                var g_d = angle_difference(turretAngle,displayTurretAngle);
                displayTurretAngle += sign(g_d)*turretTurnRate;
                break;
        }
    
        /************* FIRING *************/
        if (fire &lt;= 0) {fire += 0.1;}
        if (fire &gt; 0) {
            var a = sin(degtorad(turretAngle));
            var d = sin(degtorad(displayTurretAngle));
            
            var o = obj_player || obj_wall;
            var inView = collision_line(x+(sprite_width/2),y+(sprite_height/2),x+(sprite_width/2)+lengthdir_x(200,displayTurretAngle),y+(sprite_height/2)+lengthdir_y(200,displayTurretAngle),o,false,false);
            var distance = point_distance(x,y,obj_player.x,obj_player.y);
            if (inView &amp;&amp; distance &lt; 200) {
                if (a == d) {
                    if (!e_reload) {
                        var shell = instance_create(x+(sprite_width/2),y+(sprite_height/2),obj_enemy_shell);
                        shell.direction = displayTurretAngle;
                        shell.speed = 5;
                        shell.image_angle = shell.direction;
                        
                        fire -= 2;
                        e_reload = true;
                    }
                }
            }
            else {
                if (irandom(20) == 0) {
                    if (a == d) {
                        if (!e_reload) {
                            var shell = instance_create(x+(sprite_width/2),y+(sprite_height/2),obj_enemy_shell);
                            shell.direction = displayTurretAngle;
                            shell.speed = 5;
                            shell.image_angle = shell.direction;
                            
                            fire -= 2;
                            e_reload = true;
                        }
                    }
                }
            }
        }
    }
}
else {
    if (mp_grid_get_cell(mpGrid, x div gridSize, y div gridSize) == -1) {
        mp_grid_clear_cell(mpGrid,x div gridSize, y div gridSize);
    }
}
/************* RELOAD *************/
if (e_reload) {
    if (e_reloadTime &lt; e_reloadMaxTime) {
        e_reloadTime++;
    }
    else {
        e_reloadTime = 0;
        e_reload = false;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_shell">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*var x1 = (x+(sprite_width/2))-other.x;
var y1 = (y+(sprite_height/2))-other.y;
var x2 = lengthdir_x(1,displayBodyAngle);
var y2 = lengthdir_y(1,displayBodyAngle);
var adist = sqrt(sqr(x1)+sqr(y1));
var bdist = sqrt(sqr(x2)+sqr(y2));
var angle = arccos(dot_product(x1,y1,x2,y2)/max(1,adist*bdist))/pi;
var baseDamage = 0;*/
switch(other.type) {
    case 0: //HE
        damage = 3;
        break;
    case 1: //AP
        damage = 5;
        break;
}
enemyHealth -= damage;
if (canMove) {
    with(other) {
        part_particles_create(explosionSystem,x,y,explosionType,1);
        instance_destroy();
    }
}
if (enemyHealth &lt;= 0 &amp;&amp; canMove) {
    killList[type]++;
    repeat(5) part_particles_create(explosionSystem,x+irandom(sprite_width),y+irandom(sprite_height),explosionType,1);
    enemyHealth = 0;
    solid = false;
    canMove = false;
    if ((x &lt; view_xview[0] &amp;&amp; x &gt; view_xview[0]+view_wview[0]) &amp;&amp; (y &lt; view_yview[0] &amp;&amp; y &gt; view_yview[0]+view_hview[0])) {
        killTimer = 120;
        killType = type;
        killScore = 100*(type+1);
        switch(object_index) {
            case obj_enemy_1:
                killTypeColor = red;
                break;
            case obj_enemy_2:
                killTypeColor = c_gray;
                break;
            case obj_enemy_3:
                killTypeColor = yellow;
                break;
            case obj_enemy_4:
                killTypeColor = white;
                break;
            default:
                show_error("OBJECT '"+string(object_index)+"' DOES NOT EXISTS",true);
                break;
        }
    }
    /************* LEVEL COMPLETE *************/
    alarm[0] = 60;
    print("Left: " + string(enemiesLeft) + "    Alive: " + string(checkAliveEnemies()));
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var displayColor = white;
switch(object_index) {
    case obj_enemy_1:
        displayColor = red;
        break;
    case obj_enemy_2:
        displayColor = c_gray;
        break;
    case obj_enemy_3:
        displayColor = yellow;
        break;
    case obj_enemy_4:
        displayColor = white;
        break;
    default:
        show_error("OBJECT '"+string(object_index)+"' DOES NOT EXISTS",true);
        break;
}
if (!canMove) {
    displayColor = make_colour_hsv(colour_get_hue(displayColor),colour_get_saturation(displayColor),colour_get_value(displayColor)*0.5);
}
draw_sprite_ext(tankBody,image_index,x+(sprite_width/2),y+(sprite_height/2),1,1,displayBodyAngle,displayColor,1);
var xx, yy;
xx = lengthdir_x(fire,displayTurretAngle);
yy = lengthdir_y(fire,displayTurretAngle);
draw_sprite_ext(spr_tank_turret,0,x+(sprite_width/2)+xx,y+(sprite_height/2)+yy,1,1,displayTurretAngle,displayColor,1);

/*if (canMove) {
    draw_path(path,x,y,true);
    draw_circle(targetX,targetY,3,false);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
