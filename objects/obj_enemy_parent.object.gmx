<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>enemyMaxHealth = 5;
enemyHealth = enemyMaxHealth;

type = 1;
targetX = (irandom(room_width) div gridSize)*gridSize;
targetY = (irandom(room_height) div gridSize)*gridSize;

canMove = true;
moveSpeed = 0.5;
fire = 0;
turrentAngle = 0;
bodyAngle = 0;
displayTurrentAngle = 0;
displayBodyAngle = 0;
path = path_add();

e_reload = false;
e_reloadTime = 0;
e_reloadMaxTime = 120;
damage = 0

xPrev = x;
yPrev = y;
xTo = x;
yTo = y;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (canMove) {
    if (xTo == x &amp;&amp; yTo == y) {
        if (xPrev != xTo || yPrev != yTo) {
            mp_grid_clear_cell(mpGrid, xPrev div gridSize, yPrev div gridSize);
            xPrev = x;
            yPrev = y;
        }
        var pathFound = false;
        mp_grid_clear_cell(mpGrid, x div gridSize, y div gridSize);
        switch(type) {
            case 0: //Random
                var pathFound = mp_grid_path(mpGrid,path,x,y,targetX,targetY,false);
                if (targetX != x &amp;&amp; targetY != y) {
                    if (irandom(5) == 0) {
                        targetX = (irandom(room_width) div gridSize)*gridSize;
                        targetY = (irandom(room_height) div gridSize)*gridSize;
                    }
                }
                else {
                    targetX = (irandom(room_width) div gridSize)*gridSize;
                    targetY = (irandom(room_height) div gridSize)*gridSize;
                }
                break;
            case 1: //Chase
                if (instance_exists(obj_player)) {
                    targetX = obj_player.x;
                    targetY = obj_player.y;
                    mp_grid_clear_cell(mpGrid, targetX div gridSize, targetY div gridSize);
                    var pathFound = mp_grid_path(mpGrid,path,x,y,targetX,targetY,false);
                    mp_grid_add_cell(mpGrid, targetX div gridSize, targetY div gridSize);
                    if (!pathFound) {
                        targetX = (irandom(room_width) div gridSize)*gridSize;
                        targetY = (irandom(room_height) div gridSize)*gridSize;
                        pathFound = mp_grid_path(mpGrid,path,x,y,targetX,targetY,false);
                    }
                }
                break;
        }
        mp_grid_add_cell(mpGrid, x div gridSize, y div gridSize);
        if (pathFound) {
            xTo = (path_get_point_x(path,1) div gridSize)*gridSize;
            yTo = (path_get_point_y(path,1) div gridSize)*gridSize;
        }
        if (mp_grid_get_cell(mpGrid, xTo div gridSize, yTo div gridSize) == -1) {
            xTo = x;
            yTo = y;
        }
        else {
            mp_grid_add_cell(mpGrid, xTo div gridSize, yTo div gridSize);
        }
    }
    /*************** BODY **************/
    var a = sin(degtorad(displayBodyAngle));
    var d = sin(degtorad(direction));
    if (a == d) {
        if (x &gt; xTo) {
            if (place_free(x-min(moveSpeed,x-xTo),y)) {
                x -= min(moveSpeed,x-xTo);
                direction = 180;
            }
        }
        if (x &lt; xTo) {
            if (place_free(x+min(moveSpeed,xTo-x),y)) {
                x += min(moveSpeed,xTo-x);
                direction = 0;
            }
        }
        if (y &gt; yTo) {
            if (place_free(x,y-min(moveSpeed,y-yTo))) {
                y -= min(moveSpeed,y-yTo);
                direction = 90;
            }
        }
        if (y &lt; yTo) {
            if (place_free(x,y+min(moveSpeed,yTo-y))) {
                y += min(moveSpeed,yTo-y);
                direction = 270;
            }
        }
        image_index += 0.5;
    }
    else {
        var image_ad = angle_difference(direction,displayBodyAngle);
        displayBodyAngle += sign(image_ad);
        if (abs(image_ad) &gt; 0) {
            image_index += 0.5;
        }
    }
    if (instance_exists(obj_player)) {
        /************* TURRENT *************/
        switch(type) {
            case 0: //random
                displayTurrentAngle = displayBodyAngle;
                break;
            case 1: 
                turrentAngle = (point_direction(x,y,obj_player.x,obj_player.y) div 90)*90;
                var g_d = angle_difference(turrentAngle,displayTurrentAngle);
                displayTurrentAngle += sign(g_d);
                break;
        }
    
        /************* FIRING *************/
        if (fire &lt;= 0) {fire += 0.1;}
        if (fire &gt; 0) {
            var a = sin(degtorad(turrentAngle));
            var d = sin(degtorad(displayTurrentAngle));
            
            var inView = collision_line(x+(sprite_width/2),y+(sprite_height/2),x+(sprite_width/2)+lengthdir_x(200,displayTurrentAngle),y+(sprite_height/2)+lengthdir_y(200,displayTurrentAngle),obj_player,false,false);
            var distance = point_distance(x,y,obj_player.x,obj_player.y);
            if (inView &amp;&amp; distance &lt; 200) {
                if (a == d) {
                    if (!e_reload) {
                        var shell = instance_create(x+(sprite_width/2),y+(sprite_height/2),obj_enemy_shell);
                        shell.direction = displayTurrentAngle;
                        shell.speed = 5;
                        shell.image_angle = shell.direction;
                        
                        fire -= 2;
                        e_reload = true;
                    }
                }
            }
            else {
                if (irandom(10) == 0) {
                    if (a == d) {
                        if (!e_reload) {
                            var shell = instance_create(x+(sprite_width/2),y+(sprite_height/2),obj_enemy_shell);
                            shell.direction = displayTurrentAngle;
                            shell.speed = 5;
                            shell.image_angle = shell.direction;
                            
                            fire -= 2;
                            e_reload = true;
                        }
                    }
                }
            }
        }
    }
}
/************* DESTROYED *************/
if (enemyHealth &lt;= 0) {
    enemyHealth = 0;
    canMove = false;
}
/************* RELOAD *************/
if (e_reload) {
    if (e_reloadTime &lt; e_reloadMaxTime) {
        e_reloadTime++;
    }
    else {
        e_reloadTime = 0;
        e_reload = false;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_shell">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var x1 = (x+(sprite_width/2))-other.x;
var y1 = (y+(sprite_height/2))-other.y;
var x2 = lengthdir_x(1,direction);
var y2 = lengthdir_y(1,direction);
var adist = sqrt(sqr(x1)+sqr(y1));
var bdist = sqrt(sqr(x2)+sqr(y2));
var angle = arccos(dot_product(x1,y1,x2,y2)/max(1,adist*bdist))/pi;
damage = 3-angle;

enemyHealth -= damage;
if (enemyHealth &lt;= 0) {
    part_particles_create(explosionSystem,x,y,explosionType,1);
    var ind = instance_create(x+(sprite_width/2),y+(sprite_height/2),obj_dmg_inc);
    ind.damage = 100*(type+1);
    ind.size = 1;
    ind.wait = -30;
}
with(other) {
    part_particles_create(explosionSystem,x,y,explosionType,1);
    instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var displayColor = red;
if (!canMove) {
    displayColor = make_colour_rgb(105,0,0);
}
draw_sprite_ext(spr_tank_body,image_index,x+(sprite_width/2),y+(sprite_height/2),1,1,displayBodyAngle,displayColor,1);
var xx, yy;
xx = lengthdir_x(fire,displayTurrentAngle);
yy = lengthdir_y(fire,displayTurrentAngle);
draw_sprite_ext(spr_tank_turrent,0,x+(sprite_width/2)+xx,y+(sprite_height/2)+yy,1,1,displayTurrentAngle,displayColor,1);

/*draw_path(path,x,y,true);
draw_circle(path_get_point_x(path,1),path_get_point_y(path,1),3,false);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
